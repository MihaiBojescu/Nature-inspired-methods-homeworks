\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{url}
\usepackage{listings}
\usepackage{epstopdf}
\usepackage[inkscapeformat=png]{svg}
\usepackage[font=small,labelfont=bf]{caption}

\epstopdfDeclareGraphicsRule{.gif}{png}{.png}{convert gif:#1 png:\OutputFile}
\AppendGraphicsExtensions{.gif}

\begin{document}

\title{Single-Depot Multiple Travelling Salesman Problem optimisation using a Genetic algorithm and an Adaptive Particle Swarm Optimisation algorithm}

\author{\IEEEauthorblockN{Mihai Bojescu}
\IEEEauthorblockA{\textit{Master in Artificial Intelligence and optimisation} \\
\textit{Faculty of Computer Science of University ``Alexandru Ioan Cuza'' of Iași}\\
Iași, Romania \\
bojescu.mihai@gmail.com}
}
\maketitle

\begin{abstract}
    This document contains a study on optimising the Single-Depot, Multiple Travelling Salesman Problem using a combinatorial
    Genetic algorithm and a combinatorial Partile Swarm Optimisation algorithm named APSO, Adaptive Particle Swarm Optimisation.
    The studied problem is detailed, along with the algorithms, their inner workings, diagrams, hyperparameters, timings and
    results. The study was conducted on the eil51, berlin52, eil76, rat99 datasets with 2, 3 and 5 salesmen.
\end{abstract}

\begin{IEEEkeywords}
Single-Depot Multiple Travelling Salesman Problem, Genetic algorithm, Adaptive Particle Swarm Optimisation algorithm, SD-MTSP,
TSPLIB, optimisation, combinatorial function optimisation.
\end{IEEEkeywords}

\section{Introduction}
The Multiple Traveling Salesman Problem (MTSP) is a generalization of the well-known Traveling Salesman Problem (TSP),
where multiple salesmen are involved to visit a given number of cities exactly once and return to the initial position
with the minimum traveling cost. MTSP is highly related to other optimisation problems such as Vehicle Routing Problem (VRP)
and Task Assignment problem \cite{b1}. In this study, we will optimise the Single-Depot, Multiple Travelling Salesman Problem,
which is a variation of MTSP.

Genetic algorithms were proposed by John Holland in 1973 after many years of studying the idea of simulating evolution.
These algorithms model genetic inheritance and the Darwinian struggle for survival. Together with two other directions: evolutionary
strategies and evolutionary programming, they form the class of evolutionary algorithms \cite{b2}. In this study, we will
be using a combinatorial GA.

Particle Swarm Optimisation (PSO) algorithm is one of the most well-regarded algorithm in the literature of stochastic optimisation
approaches. It belongs to the family of swarm-based techniques and is a population-based algorithm. As GA and ACO, it is
of the most well-regarded algorithm in the literature. There are different versions of this algorithm in the literature
to solve constrained, dynamic, discrete, multi-objective, multi-modal, and many-objective problems \cite{b3}. In this study,
we will be using a modified PSO which can work with combinatorial problems.

This paper will apply the algorithms stated above in order to minimise the problem stated above.

\section{Single-Depot, Multiple Travelling Salesman Problem}
MTSP is one of the most important optimisation problems, and it has been applied in several real-life scenarios. Depending
on the application requirements, the salesmen in MTSP can be represented by ground vehicles such as robots or trucks, or by
flying vehicles such as Unmanned Aerial Vehicles (UAVs) known also as drones. Whereas the cities to be visited by the salesmen
can have different representations, such as customers in transportation and delivery services, sensor nodes for Wireless Sensor
Networks data collection, targets in military applications, victims in emergency missions and critical sites in disaster management
applications \cite{b1}.

MTSP is a multi-goal problem. Given $n$ salesmen and $m$ cities, the problem seeks to optimise the following two goals:
\begin{enumerate}
    \item To minimise the total tour cost of $n$ salesman that have to visit $m$ cities, at the end returning to the ``home'' city
    \item To minimise the tour cost of $n$ salesmen that have to visit $m$ cities, at the end returning to the ``home'' city
\end{enumerate}

Mathematically, MTSP can be expressed in the following way: Given $n \in \mathbb{N}$ salesmen and $m \in \mathbb{N}$ cities,
the tour definition

\begin{equation}
    tour_i = \{city | city \in \{1, ..., m\}\}, i \in \{1, ..., n\}
\end{equation}

\begin{equation}
    tour_i \cap tour_j = \emptyset, i \ne j, i \in \{1, ..., n\}, j \in \{1, ..., n\}
\end{equation}

\begin{equation}
    \bigcup_{i = 1}^{n} tour_i = \{1, ..., m\}
\end{equation}

\begin{equation} \label{tour maximum length}
    |tour| \leq \lfloor \frac{m - 1 + n}{n} + 1 \rfloor
\end{equation}

and the cost function

\begin{multline} \label{cost function}
    cost(tour) = (\sum_{i = 1}^{k - 1} distance^2(city_{i}, city_{i+1})) + \\
    distance^2(city_k, city_1), k = |tour|
\end{multline}


find a combination of tours such that

\begin{equation}
    minimise(\sum_{i = 1}^{n} cost(tour_i))
\end{equation}

and

\begin{equation}
    minimise(cost(tour_i)), \forall i \in \{1, ..., n\}
\end{equation}

are satisfied.

The MTSP problem can be optimised using multiple heuristic algorithms: Artificial Neural Networks (ANNs), Simulated
Annealing algorithms (SAs), Particle Swarm Optimisation algorithms (PSOs), Genetic algorithms (GAs), Ant Colony Optimisation
algorithms (ACOs) etc. \cite{b4}.


\section{Genetic Algorithm}

\subsection{Introduction}
In literature, Genetic Algorithms are regarded as highly effective for optimising the MTSP, thus they are extensively used (Xu
et al. 2018) due to their convergence speed, their main drawback being their high dependence on a well-generated, diverse initial
population.

Multiple Genetic Algorithms were proposed, ranging from their chromosome representation and used genetic operators.

For chromosome representations, Tang et al. (2000) suggested a one-chromosome representation for optimising MTSP and was
used for tackling the hot rolling production scheduling problem. Carter and Ragsdale (2006) proposed a two-part chromosome
representation and relevant operators. Brown et al. (2007) proposed a one-chromosome and two-chromosome representation, while
Yuan et al. (2013) proposed another two-part chromosome representation algorithm.

As for genetic operators, many used simple swap, slide and reverse-swap operators for the mutation operator. For the crossover
operator, Király and Abonyi (2011) proposed a two-point crossover operator, Lo et al (2018) proposed a edge-recombination crossover
operator, Sedighpour et al. (2012) proposed an order crossover operator, and Singh et al. (2018) proposed a distance-preserving
crossover operator for solving the MTSP.

\subsection{Hyperparameters}
In this paper, the following hyperparameters were chosen:
\begin{enumerate}
    \item population size = 100
    \item generations = 2000
    \item mutation chance = 0.1
\end{enumerate}

\subsection{Population generation}
In this paper, a population of 100 individuals was generated randomly and was segmented in multiple tours with their maximum
length according to formula \ref{tour maximum length}, in order to match the tour sizes in the provided datasets \cite{b5}.

\subsection{Chromosome representation}
In this paper, a one-chromosome representation was used, where each chromosome was wrapped in an class named ``Individual''
that handled its own fitness calculations using formula \ref{cost function}. Each ``Individual'' represents a full solution
for the MTSP. The tours in the ``Individual'' are entities of type \texttt{t.List[t.List[int]]} with their home depot omitted,
and the fitness value of the solution is represented as a \texttt{float} variable. An example of an individual can be found
in the code listing below.

\begin{lstlisting}[caption=Example of individual,captionpos=b]
Individual(
    genes=[
        [39, 47,  4, 24, 25, 26, 27, 11,
         50, 32, 42,  9,  8,  2, 48, 34,
         43, 15, 28, 49, 19, 22, 30, 20],
        [46, 12, 13, 51, 10,  3,  5, 14,
         37, 23, 45, 36, 38, 35, 33, 21,
         31, 44,  7, 40, 18, 17, 16,  6,
          1, 41, 29]
    ],
    fitness=10361.20300592295
)
\end{lstlisting} 

\subsection{Selection operator}
In this paper, a tournament selection operator was used, where $size(tournament) = 10$, thus from a random selection of 10
individuals, only the best one is picked. There were attempts to use the roulette wheel selection, but the results of using
the tournament selection operator were better.

\subsection{Crossover operator}
For the crossover operator, the distance-preserving crossover operator was used as described by Singh et al. (2018). The operator,
originally used on chromosomes with two-part representation, was \textit{trivially} adapted to work using one-chromosome
representations. In order for the operator to be used, an encoder was created that, given a segmentation, can encode the
tours from a \texttt{t.List[t.List[int]]} to a \texttt{t.List[int]} and decode them back.

The operator, given parents $parent_{1}$ and $parent_{2}$ produces children $child_{1}$ and $child_{2}$ in the following manner:
\begin{enumerate}
    \item Encode the tours of $parent_{1}$ into a list of ints, $parent_{1}^{e}$
    \item Encode the tours of $parent_{2}$ into a list of ints, $parent_{2}^{e}$
    \item Create child $child_{1}^{e}$ of length $|parent_{1}^{e}|$
    \item Create child $child_{2}^{e}$ of length $|parent_{2}^{e}|$
    \item Copy last gene of $parent_{2}^{e}$ into first gene of $child_{1}^{e}$
    \item Copy last gene of $parent_{1}^{e}$ into first gene of $child_{2}^{e}$
    \item Copy first gene of $parent_{2}^{e}$ into last gene of $child_{1}^{e}$
    \item Copy first gene of $parent_{1}^{e}$ into last gene of $child_{2}^{e}$
    \item For $i = \{1, ..., |parent_{1}^{e}|\}, j = \{2, ..., |parent_{1}^{e}| - 1\}$:
    \begin{enumerate}
        \item If $i^{th}$ gene of $parent_{2}^{e}$ is equal to $j^{th}$ gene of $parent_{1}^{e}$, then copy $j^{th}$ gene of
        $parent_{2}^{e}$ into $j^{th}$ gene of $child_{1}^{e}$
        \item If $i^{th}$ gene of $parent_{1}^{e}$ is equal to $j^{th}$ gene of $parent_{2}^{e}$, then copy $j^{th}$ gene of
        $parent_{1}^{e}$ into $j^{th}$ gene of $child_{2}^{e}$
    \end{enumerate}
    \item Decode $child_{1}^{e}$ into the tours for $child_{1}$
    \item Decode $child_{2}^{e}$ into the tours for $child_{2}$
\end{enumerate}

An example can be found in the figure below:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{images/crossover.png}
    \caption{Crossover operator}
\end{figure}


The justification behind this crossover strategy depends on the idea that the city in optimal/suboptimal tour takes place
in the same location \cite{b6}.

\subsection{Mutation operator}
The mutation operator in this paper is comprised of 3 operations, each executed according to the mutation chance hyperparameter:

\begin{enumerate}
    \item Swap operation
    \item Slide operation
    \item Reverse-swap operation
\end{enumerate}

The swap operation, randomly picking two position $a$ and $b$ with $a, b \leq |genes_{child}|$, performs a simple swap between
gene $a$ and gene $b$ of the child:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.20\textwidth]{images/mutation.png}
    \caption{Swap operator}
\end{figure}

The slide operator, randomly picking two position $a$ and $b$ with $a, b \leq |genes_{child}|$, moves gene $a$ to gene
$b$ and slides each gene before gene $b$ one step before.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.20\textwidth]{images/mutation 2.png}
    \caption{Slide operator}
\end{figure}

The reverse-swap operator, randomly picking two position $a$ and $b$ with $a, b \leq |genes_{child}|$, reverses the genes
array between gene $a$ and gene $b$, including gene $a$ and gene $b$.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.20\textwidth]{images/mutation 3.png}
    \caption{Reverse-swap operator}
\end{figure}

\begin{thebibliography}{00}
    \bibitem{b1} O. Cheikhrouhou, I. Khoufi (2021). ``A comprehensive survey on the Multiple Traveling Salesman Problem: Applications, approaches and taxonomy''. Computer Science Review, 40, 100369. doi: 10.1016/j.cosrev.2021.1003.
    \bibitem{b2} L. Henri, E. Croitoru (2022). ``Genetic algorithms''. Faculty of Computer Science of University ``Alexandru Ioan Cuza'' of Iași.
    \bibitem{b3} S. Mirjalili (2018). ``Particle Swarm Optimisation. Evolutionary Algorithms and Neural Networks''. 15-31. doi: 10.1007/978-3-319-93025-1\_2.
    \bibitem{b4} M. A. Al-Furhud, Z. H. Ahmed (2020). ``Experimental Study of a Hybrid Genetic Algorithm for the Multiple Travelling Salesman Problem''. Mathematical Problems in Engineering, vol. 2020, p. 3431420. doi: 10.1155/2020/3431420.
    \bibitem{b5} \url{https://profs.info.uaic.ro/~mtsplib/MinMaxMTSP/index.html}
    \bibitem{b6} P. Singamsetty, J. K. Thenepalledoi (2021). ``An efficient genetic algorithm for solving open multiple travelling salesman problem with load
    balancing constraint''. Department of Mathematics, School of Advanced Sciences, VIT, Vellore-632014, Tamil Nadu, India. doi: 10.5267/j.dsl.2021.5.003
\end{thebibliography}
    
\end{document}
